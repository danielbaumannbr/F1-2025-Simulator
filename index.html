<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador F1 2025 ‚Äî Pista e Corrida</title>
  <style>
    :root{ --bg:#0b1020; --panel:#0f1724; --accent:#00d2be; color-scheme: dark; }
    html,body{ height:100%; margin:0; font-family: Inter, system-ui, Arial; background: linear-gradient(180deg,#071022 0%, #0b1220 100%); color:#e6eef6 }
    .app{display:grid; grid-template-columns: 1fr 360px; gap:16px; padding:16px; height:100vh; box-sizing:border-box}
    .track-panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04)); border-radius:12px; padding:12px; box-shadow: 0 6px 18px rgba(2,6,23,0.6); position:relative}
    header{ display:flex; align-items:center; gap:12px; margin-bottom:8px }
    header h1{ font-size:18px; margin:0 }
    .controls{ background:var(--panel); padding:12px; border-radius:12px;}
    .controls button{ padding:8px 12px; margin-right:6px; border-radius:8px; border:none; background:#162434; color:#e6eef6; cursor:pointer }
    .controls .danger{ background:#8b1a2f }
    .info{ margin-top:12px; font-size:13px; line-height:1.4 }
    svg{ width:100%; height:calc(100vh - 120px); display:block; }
    .hud{ position:absolute; left:14px; top:14px; background:rgba(2,6,23,0.6); padding:8px 10px; border-radius:10px; font-size:13px }
    .standings{ font-size:13px }
    .team-row{ display:flex; align-items:center; gap:8px; margin:6px 0 }
    .dot{ width:14px; height:14px; border-radius:50% }
    footer{ font-size:12px; opacity:0.8; margin-top:10px }
    /* small responsive */
    @media(max-width:900px){ .app{ grid-template-columns: 1fr; grid-auto-rows:min-content } svg{ height:50vh } }
    
    /* New standings panel */
    .standings-panel {
      position: absolute;
      left: 14px;
      bottom: 14px;
      background: rgba(2,6,23,0.6);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      max-height: 40%;
      overflow-y: auto;
      width: 200px;
    }
    .standings-panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      text-align: center;
    }
    .driver-row {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
      padding: 4px 6px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
    }
    .driver-row.retired {
      opacity: 0.5;
      text-decoration: line-through;
    }
    .driver-name {
      font-weight: bold;
    }
    .driver-gap {
      font-family: monospace;
      font-size: 12px;
    }
    .driver-pos {
      display: inline-block;
      width: 20px;
      text-align: right;
      margin-right: 6px;
    }
    .driver-tire {
      font-size: 10px;
      opacity: 0.7;
      margin-left: 4px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="track-panel">
      <header>
        <h1>Simulador F1 2025 ‚Äî Pista estilizada</h1>
        <div style="margin-left:auto; font-size:13px; opacity:0.9">Voltas: <span id="totalLaps">30</span></div>
      </header>

      <div class="hud">
        <div><strong>Tempo de corrida:</strong> <span id="raceTime">00:00</span></div>
        <div><strong>Volta:</strong> <span id="currentLap">0</span>/<span id="laps">30</span></div>
        <div><strong>L√≠der:</strong> <span id="leader">-</span></div>
      </div>

      <!-- SVG pista: caminho em forma de la√ßo com retas e curvas -->
      <svg id="trackSVG" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet">
        <defs>
          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="6" stdDeviation="8" flood-opacity="0.45"/>
          </filter>
        </defs>

        <!-- grama -->
        <rect x="0" y="0" width="1200" height="700" fill="#083" opacity="0.04" />

        <!-- pista: base path (center-line) -->
        <path id="centerPath" d="M150,350 C150,150 450,100 600,120 C850,160 1050,120 1050,350 C1050,550 800,600 600,580 C400,560 200,500 150,350 Z" fill="none" stroke="transparent" />

        <!-- draw track ribbons: using stroke with wide line to simulate track -->
        <path d="M150,350 C150,150 450,100 600,120 C850,160 1050,120 1050,350 C1050,550 800,600 600,580 C400,560 200,500 150,350 Z" fill="none" stroke="#222" stroke-width="120" stroke-linejoin="round" stroke-linecap="round" />
        <path d="M150,350 C150,150 450,100 600,120 C850,160 1050,120 1050,350 C1050,550 800,600 600,580 C400,560 200,500 150,350 Z" fill="none" stroke="#6b6b6b" stroke-width="40" stroke-linejoin="round" stroke-linecap="round" opacity="0.5" />

        <!-- kerbs / curbs (decorative) -->
        <g id="curbs">
          <!-- a few sample curbs by small arcs -->
          <circle cx="380" cy="110" r="12" fill="#ff0000" />
          <circle cx="920" cy="140" r="12" fill="#ffffff" />
          <circle cx="980" cy="450" r="12" fill="#ff0000" />
          <circle cx="300" cy="460" r="12" fill="#ffffff" />
        </g>

        <!-- start/finish line -->
        <g id="startFinish" transform="translate(600,40)">
          <rect x="-6" y="0" width="12" height="80" fill="#fff"/>
        </g>

        <!-- cars layer (will be filled by JS) -->
        <g id="carsLayer"></g>

        <!-- minimal map legend -->
        <g transform="translate(20,560)" font-size="12">
          <rect x="-10" y="-22" width="190" height="120" rx="8" fill="#071426" opacity="0.6" />
        </g>
      </svg>

      <!-- New standings panel -->
      <div class="standings-panel">
        <h3>Classifica√ß√£o</h3>
        <div id="standingsList"></div>
      </div>

    </div>

    <aside class="controls">
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="startBtn">Iniciar</button>
        <button id="pauseBtn">Pausar</button>
        <button id="resetBtn" class="danger">Reset</button>
      </div>

      <div style="margin-top:10px">
        <label>Velocidade da simula√ß√£o: <span id="speedLabel">1x</span></label>
        <input id="speed" type="range" min="0.25" max="4" step="0.25" value="1" style="width:100%" />
      </div>

      <div style="margin-top:12px">
        <label>Voltas da corrida</label>
        <input id="lapInput" type="number" min="5" max="80" value="30" style="width:100%; padding:6px; margin-top:6px; border-radius:8px; border:none; background:#081426; color:#e6eef6" />
      </div>

      <div class="info">
        <strong>Regras simuladas (resumo)</strong>
        <ul>
          <li>Pontua√ß√£o: 25-18-15-12-10-8-6-4-2-1 para top10</li>
          <li>1 ponto para volta mais r√°pida (condi√ß√£o: top10)</li>
          <li>Parada nos boxes aplica +18s (tempo fixo de pitstop)</li>
          <li>Retirada aleat√≥ria (falha) poss√≠vel; safety car simulado (neutraliza por 5 a 12s)</li>
          <li>Ultrapassagens baseadas em diferen√ßa de performance + RNG</li>
        </ul>
      </div>

      <div style="margin-top:12px">
        <strong>Equipas 2025 (n√∫mero e cor principal)</strong>
        <div id="teamsList" class="standings"></div>
      </div>

      <footer>
        Gerado automaticamente. Fonte dos nomes e n√∫meros: Formula1.com / FIA (2025).
        Dados de performance baseados em estat√≠sticas reais at√© agosto/2025.
      </footer>
    </aside>
  </div>

  <script>
    /************************************************************************
     * Dados 2025 atualizados com performance real (at√© agosto/2025)
     * Fontes: Formula1.com, ESPN, Sky Sports 
     *************************************************************************/
    const TEAMS = [
      { 
        team: 'Red Bull Racing', 
        drivers: [
          {name: 'Max Verstappen', number: 1, perf: 1.05}, // 9.5/10 rating
          {name: 'Yuki Tsunoda', number: 22, perf: 0.85}   // 5/10 estimado
        ], 
        color: '#1E41FF',
        teamPerf: 0.95  // 4¬∫ melhor carro
      },
      { 
        team: 'Mercedes', 
        drivers: [
          {name: 'George Russell', number: 63, perf: 1.02}, // 9/10 rating
          {name: 'Kimi Antonelli', number: 12, perf: 0.88}  // 6.5/10 rating
        ], 
        color: '#00D2BE',
        teamPerf: 0.97  // 3¬∫ melhor carro
      },
      { 
        team: 'Ferrari', 
        drivers: [
          {name: 'Charles Leclerc', number: 16, perf: 1.03}, // 9/10 rating
          {name: 'Lewis Hamilton', number: 44, perf: 0.92}   // 7/10 rating
        ], 
        color: '#DC0000',
        teamPerf: 0.98  // 2¬∫ melhor carro
      },
      { 
        team: 'McLaren', 
        drivers: [
          {name: 'Lando Norris', number: 4, perf: 1.06},   // 8.5/10 rating
          {name: 'Oscar Piastri', number: 81, perf: 1.07}  // 9/10 rating
        ], 
        color: '#FF8700',
        teamPerf: 1.05  // Melhor carro
      },
      { 
        team: 'Aston Martin', 
        drivers: [
          {name: 'Fernando Alonso', number: 14, perf: 0.93}, // 7/10 rating
          {name: 'Lance Stroll', number: 18, perf: 0.82}     // 6/10 rating
        ], 
        color: '#006F62',
        teamPerf: 0.82  // 8¬∫ melhor carro
      },
      { 
        team: 'Alpine', 
        drivers: [
          {name: 'Jack Doohan', number: 7, perf: 0.87},    // 6/10 estimado
          {name: 'Pierre Gasly', number: 10, perf: 0.89}   // 7/10 estimado
        ], 
        color: '#005AFF',
        teamPerf: 0.88  // 6¬∫ melhor carro
      },
      { 
        team: 'Haas', 
        drivers: [
          {name: 'Esteban Ocon', number: 31, perf: 0.91},  // 7/10 rating
          {name: 'Oliver Bearman', number: 87, perf: 0.85} // 6.5/10 estimado
        ], 
        color: '#FFFFFF',
        teamPerf: 0.86  // 7¬∫ melhor carro
      },
      { 
        team: 'Williams', 
        drivers: [
          {name: 'Alexander Albon', number: 23, perf: 0.96}, // 7.5/10 rating
          {name: 'Carlos Sainz', number: 55, perf: 0.90}     // 7/10 estimado
        ], 
        color: '#0050D0',
        teamPerf: 0.92  // 5¬∫ melhor carro
      },
      { 
        team: 'Sauber', 
        drivers: [
          {name: 'Nico Hulkenberg', number: 27, perf: 0.89}, // 7.5/10 rating
          {name: 'Gabriel Bortoleto', number: 5, perf: 0.80}  // 5/10 estimado
        ], 
        color: '#00B3AD',
        teamPerf: 0.80  // 10¬∫ melhor carro
      },
      { 
        team: 'Racing Bulls', 
        drivers: [
          {name: 'Liam Lawson', number: 21, perf: 0.84},    // 6/10 estimado
          {name: 'Isack Hadjar', number: 24, perf: 0.82}    // 5.5/10 estimado
        ], 
        color: '#D62828',
        teamPerf: 0.83  // 9¬∫ melhor carro
      }
    ];

    // Function to get FIA-style 3-letter driver abbreviation
    function getDriverAbbreviation(name) {
      const parts = name.split(' ');
      if (parts.length === 1) return parts[0].substring(0, 3).toUpperCase();
      
      // Special cases for known drivers
      const specialCases = {
        'Max Verstappen': 'VER',
        'Lewis Hamilton': 'HAM',
        'George Russell': 'RUS',
        'Charles Leclerc': 'LEC',
        'Lando Norris': 'NOR',
        'Carlos Sainz': 'SAI',
        'Fernando Alonso': 'ALO',
        'Lance Stroll': 'STR',
        'Pierre Gasly': 'GAS',
        'Esteban Ocon': 'OCO',
        'Yuki Tsunoda': 'TSU',
        'Nico Hulkenberg': 'HUL',
        'Alexander Albon': 'ALB',
        'Oscar Piastri': 'PIA',
        'Kimi Antonelli': 'ANT',
        'Jack Doohan': 'DOO',
        'Oliver Bearman': 'BEA',
        'Gabriel Bortoleto': 'BOR',
        'Liam Lawson': 'LAW',
        'Isack Hadjar': 'HAD'
      };
      
      if (specialCases[name]) return specialCases[name];
      
      // Default pattern: first 3 letters of last name
      return parts[parts.length - 1].substring(0, 3).toUpperCase();
    }

    // Get tire symbol for display
    function getTireSymbol(tireType) {
      const tires = {
        'soft': 'üü•',
        'medium': 'üü®',
        'hard': '‚¨ú',
        'intermediate': 'üü©',
        'wet': 'üü¶'
      };
      return tires[tireType] || '?';
    }

    // Get track-specific performance multiplier
    function getTrackSpecificPerformance(driver, trackType) {
      // Exemplo: ajustes baseados em caracter√≠sticas de pilotos
      const driverSpecialties = {
        'Max Verstappen': { street: 1.02, power: 1.03, downforce: 1.01 },
        'Charles Leclerc': { street: 1.05, power: 0.98, downforce: 1.04 },
        'Lewis Hamilton': { street: 1.04, power: 0.97, downforce: 0.99 },
        'George Russell': { street: 1.01, power: 1.02, downforce: 1.00 },
        'Lando Norris': { street: 0.99, power: 1.01, downforce: 1.03 },
        'Oscar Piastri': { street: 0.98, power: 1.02, downforce: 1.05 },
        'Alexander Albon': { street: 1.03, power: 0.96, downforce: 0.98 },
        'Carlos Sainz': { street: 1.01, power: 0.99, downforce: 1.00 },
        'Fernando Alonso': { street: 1.05, power: 0.95, downforce: 0.97 },
        'Nico Hulkenberg': { street: 1.00, power: 1.01, downforce: 0.99 }
      };
      
      const specialty = driverSpecialties[driver.name] || {};
      return specialty[trackType] || 1.0;
    }

    // Ajuste final de performance combinando driverPerf e teamPerf
    const GRID = [];
    TEAMS.forEach(t => t.drivers.forEach(d => GRID.push({
      team: t.team,
      name: d.name,
      num: d.number,
      color: t.color,
      teamColor: t.color,
      perf: (d.perf * 0.7 + t.teamPerf * 0.3), // 70% piloto, 30% carro
      abbreviation: getDriverAbbreviation(d.name),
      currentTire: ['soft', 'medium', 'hard'][Math.floor(Math.random() * 3)] // Random starting tire
    })));

    // Shuffle grid for random starting positions
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Shuffle the grid for more realistic starting positions
    const SHUFFLED_GRID = shuffleArray([...GRID]);

    // HTML refs
    const carsLayer = document.getElementById('carsLayer');
    const lapsInput = document.getElementById('lapInput');
    const totalLapsSpan = document.getElementById('totalLaps');
    const lapsSpan = document.getElementById('laps');
    const currentLapSpan = document.getElementById('currentLap');
    const raceTimeSpan = document.getElementById('raceTime');
    const leaderSpan = document.getElementById('leader');
    const teamsList = document.getElementById('teamsList');
    const standingsList = document.getElementById('standingsList');

    // populate teams list
    TEAMS.forEach(t => {
      const div = document.createElement('div'); div.className='team-row';
      const dot = document.createElement('span'); dot.className='dot'; dot.style.background=t.color; div.appendChild(dot);
      const txt = document.createElement('div'); txt.innerHTML = `<strong style="font-size:13px">${t.team}</strong><div style="font-size:12px; opacity:0.9">${t.drivers.map(d=>d.number+' ‚Äî '+d.name).join(' / ')}</div>`;
      div.appendChild(txt); teamsList.appendChild(div);
    });

    // Simulation state
    let SIM = {
      running: false,
      time: 0,
      speed: 1,
      lapTime: 90, // lap duration baseline (s)
      cars: [],
      totalLaps: parseInt(lapsInput.value),
      currentLap: 0,
      lastTimestamp: 0,
      safetyCar: false,
      safetyCarEndTime: 0,
      trackType: 'downforce', // 'downforce', 'power', or 'street'
      animationId: null
    };

    // prepare path length and helper: get point on path
    const path = document.getElementById('centerPath');
    const pathLen = path.getTotalLength();

    // Function to update standings panel
    function updateStandings() {
      const aliveCars = SIM.cars.filter(c => !c.retired).sort((a, b) => a.totalTime - b.totalTime);
      standingsList.innerHTML = '';
      
      aliveCars.forEach((car, index) => {
        const row = document.createElement('div');
        row.className = `driver-row ${car.retired ? 'retired' : ''}`;
        
        const gap = index === 0 ? 'LDR' : 
                   car.laps < aliveCars[0].laps ? `${aliveCars[0].laps - car.laps}L` : 
                   `+${formatGap(car.totalTime - aliveCars[0].totalTime)}`;
        
        row.innerHTML = `
          <div class="driver-name">
            <span class="driver-pos">${index + 1}</span>
            ${car.model.abbreviation}
          </div>
          <div class="driver-gap">${gap}</div>
          <div class="driver-tire">${getTireSymbol(car.model.currentTire)}</div>
        `;
        
        // Set color indicator
        row.style.borderLeft = `3px solid ${car.model.color}`;
        
        standingsList.appendChild(row);
      });
      
      // Add retired cars at the bottom
      const retiredCars = SIM.cars.filter(c => c.retired);
      if (retiredCars.length > 0) {
        const retiredHeader = document.createElement('div');
        retiredHeader.textContent = 'Retirados:';
        retiredHeader.style.marginTop = '8px';
        retiredHeader.style.opacity = '0.7';
        standingsList.appendChild(retiredHeader);
        
        retiredCars.forEach((car, index) => {
          const row = document.createElement('div');
          row.className = 'driver-row retired';
          row.innerHTML = `
            <div class="driver-name">
              <span class="driver-pos">${aliveCars.length + index + 1}</span>
              ${car.model.abbreviation}
            </div>
            <div class="driver-gap">DNF</div>
          `;
          row.style.borderLeft = `3px solid ${car.model.color}`;
          standingsList.appendChild(row);
        });
      }
    }

    // Format gap time for display
    function formatGap(seconds) {
      if (seconds < 1) return seconds.toFixed(3);
      if (seconds < 60) return seconds.toFixed(1);
      
      const mins = Math.floor(seconds / 60);
      const secs = (seconds % 60).toFixed(1);
      return `${mins}:${secs.padStart(4, '0')}`;
    }

    // create car SVG elements
    function initCars() {
      carsLayer.innerHTML = '';
      SIM.cars = SHUFFLED_GRID.map((g, i) => {
        const pct = i / SHUFFLED_GRID.length * 0.02; // small stagger on grid
        const el = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        el.setAttribute('transform', 'translate(0,0)');
        el.setAttribute('data-num', g.num);

        // circle
        const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circ.setAttribute('r', 14);
        circ.setAttribute('fill', g.color);
        circ.setAttribute('stroke', '#111');
        circ.setAttribute('stroke-width', 2);
        circ.setAttribute('filter', 'url(#shadow)');
        el.appendChild(circ);
        
        // number text
        const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        txt.setAttribute('y', 5);
        txt.setAttribute('x', -7);
        txt.setAttribute('font-size', 10);
        txt.setAttribute('fill', '#fff');
        txt.textContent = g.num;
        el.appendChild(txt);

        carsLayer.appendChild(el);

        return {
          id: i,
          model: g,
          el,
          circ,
          txt,
          pos: pct * pathLen,
          laps: 0,
          lapTimeAccum: 0,
          totalTime: 0,
          inPit: false,
          retired: false,
          finished: false,
          inTraffic: false,
          pitCount: 0
        };
      });
    }

    // update positions visually
    function render() {
      SIM.cars.forEach(c => {
        const p = path.getPointAtLength(c.pos % pathLen);
        c.el.setAttribute('transform', `translate(${p.x}, ${p.y})`);
        
        // Update tire wear visual (color intensity)
        const tireWear = 1.0 - (c.laps / SIM.totalLaps * 0.2);
        c.circ.setAttribute('opacity', tireWear);
      });
      
      // Update standings panel
      updateStandings();
    }

    // race tick: advance simulation by dt seconds
    function tick(dt) {
      if (!SIM.running) return;
      
      // determine lap baseline ‚Äî dt moves by distance proportional to lapTime
      const lapSpeedScalar = pathLen / SIM.lapTime; // px per sec for baseline

      // random events: small chance of safety car or retire
      if (Math.random() < 0.0005 * SIM.speed && !SIM.safetyCar) {
        // small chance of random retirement
        const alive = SIM.cars.filter(c => !c.retired);
        if (alive.length > 6) {
          const pick = alive[Math.floor(Math.random() * alive.length)];
          pick.retired = true;
          pick.circ.setAttribute('opacity', 0.2);
          
          // 30% chance of safety car when a car retires
          if (Math.random() < 0.3) {
            SIM.safetyCar = true;
            SIM.safetyCarEndTime = SIM.time + 8 + Math.random() * 4; // 8-12s safety car
          }
        }
      }

      // Check safety car end
      if (SIM.safetyCar && SIM.time >= SIM.safetyCarEndTime) {
        SIM.safetyCar = false;
      }

      // move each car
      SIM.cars.forEach((c, idx) => {
        if (c.retired || c.finished) return;
        
        // Check if car is in traffic (within 0.5s of car ahead)
        c.inTraffic = false;
        const carsAhead = SIM.cars.filter(car => 
          !car.retired && !car.finished && 
          car.pos > c.pos && (car.pos - c.pos) < (0.5 * lapSpeedScalar)
        if (carsAhead.length > 0) c.inTraffic = true;
        
        // performance affects speed
        const trackPerf = getTrackSpecificPerformance(c.model, SIM.trackType);
        const effectivePerf = c.model.perf * trackPerf;
        
        // tire wear effect (lose 20% performance by end of race)
        const tireWear = 1.0 - (c.laps / SIM.totalLaps * 0.2);
        
        // dirty air penalty when following another car
        const dirtyAirPenalty = c.inTraffic ? 0.97 : 1.0;
        
        // safety car effect - all cars slow down
        const safetyCarEffect = SIM.safetyCar ? 0.5 : 1.0;
        
        // small randomness + team penalties
        const variability = (Math.sin((SIM.time + idx * 3) / 10) * 0.002 + (Math.random() - 0.5) * 0.01);
        
        const speedPx = lapSpeedScalar * effectivePerf * tireWear * dirtyAirPenalty * safetyCarEffect * 
                       (1 + variability);
        
        c.pos += speedPx * (dt * SIM.speed);

        // lap counting
        const lapsCompleted = Math.floor(c.pos / pathLen);
        if (lapsCompleted > c.laps) {
          c.laps = lapsCompleted;
          
          // pitstop chance on lap (higher chance if on soft tires)
          let pitChance = 0.06;
          if (c.model.currentTire === 'soft') pitChance = 0.12;
          if (c.model.currentTire === 'hard') pitChance = 0.03;
          
          if (Math.random() < pitChance && c.pitCount < 2) { 
            c.inPit = true; 
            c.pos += -60; 
            c.totalTime += 18; // pitstop penalty
            c.pitCount++;
            
            // Change tires (random strategy)
            const tireOptions = ['soft', 'medium', 'hard'];
            c.model.currentTire = tireOptions[Math.floor(Math.random() * tireOptions.length)];
          }
        }

        // total time estimate
        c.totalTime = (c.pos / pathLen) * SIM.lapTime / (effectivePerf * tireWear * dirtyAirPenalty * safetyCarEffect);
      });

      // Update simulation time
      SIM.time += dt * SIM.speed;

      // update HUD
      SIM.currentLap = Math.max(...SIM.cars.map(c => c.laps));
      currentLapSpan.textContent = SIM.currentLap;
      raceTimeSpan.textContent = formatTime(Math.floor(SIM.time));
      
      // Show safety car indicator if active
      if (SIM.safetyCar) {
        leaderSpan.textContent = "SAFETY CAR";
      } else {
        // leader determination by totalTime ascending (lower = better)
        const aliveCars = SIM.cars.filter(c => !c.retired);
        aliveCars.sort((a, b) => a.totalTime - b.totalTime);
        leaderSpan.textContent = aliveCars.length ? aliveCars[0].model.name + ' #' + aliveCars[0].model.num : '-';
      }

      // check race end: if any car completed totalLaps
      const finished = SIM.cars.filter(c => c.laps >= SIM.totalLaps && !c.finished);
      if (finished.length) {
        finished.forEach(f => f.finished = true);
      }
      const finishedCount = SIM.cars.filter(c => c.finished).length;
      if (finishedCount >= 1) {
        // if at least one finished and simulation time beyond limit, stop when top3 finished
        if (SIM.cars.filter(c => c.finished).length >= 3) {
          stopRace();
        }
      }

      render();
    }

    function formatTime(s) {
      const mm = String(Math.floor(s / 60)).padStart(2, '0');
      const ss = String(s % 60).padStart(2, '0');
      return `${mm}:${ss}`;
    }

    // Animation loop
    function runLoop(timestamp) {
      if (!SIM.running) return;
      
      if (!SIM.lastTimestamp) {
        SIM.lastTimestamp = timestamp;
      }
      
      const dt = (timestamp - SIM.lastTimestamp) / 1000; // Convert to seconds
      SIM.lastTimestamp = timestamp;
      
      tick(dt);
      
      SIM.animationId = requestAnimationFrame(runLoop);
    }

    // start/pause/reset handlers
    document.getElementById('startBtn').addEventListener('click', () => {
      if (!SIM.running) {
        SIM.running = true;
        SIM.lastTimestamp = 0; // Reset timestamp
        SIM.animationId = requestAnimationFrame(runLoop);
      }
    });
    
    document.getElementById('pauseBtn').addEventListener('click', () => {
      SIM.running = false;
      if (SIM.animationId) {
        cancelAnimationFrame(SIM.animationId);
        SIM.animationId = null;
      }
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      SIM.running = false;
      if (SIM.animationId) {
        cancelAnimationFrame(SIM.animationId);
        SIM.animationId = null;
      }
      resetRace();
    });
    
    document.getElementById('speed').addEventListener('input', e => {
      SIM.speed = parseFloat(e.target.value);
      document.getElementById('speedLabel').textContent = SIM.speed + 'x';
    });
    
    lapsInput.addEventListener('change', e => {
      SIM.totalLaps = parseInt(e.target.value);
      totalLapsSpan.textContent = SIM.totalLaps;
      lapsSpan.textContent = SIM.totalLaps;
    });

    function stopRace() {
      SIM.running = false;
      if (SIM.animationId) {
        cancelAnimationFrame(SIM.animationId);
        SIM.animationId = null;
      }
      
      // compute final classification
      const finishOrder = SIM.cars.filter(c => c.finished || !c.retired)
                                 .sort((a, b) => a.totalTime - b.totalTime)
                                 .slice(0, 10);
      // show podium
      setTimeout(() => {
        const podium = finishOrder.slice(0, 3)
          .map((c, i) => `${i+1}¬∫ ‚Äî ${c.model.name} (#${c.model.num}) ‚Äî ${formatTime(c.totalTime)}`)
          .join('\n');
        alert('P√≥dio:\n' + podium);
      }, 200);
    }

    function resetRace() {
      SIM.running = false;
      SIM.time = 0;
      SIM.currentLap = 0;
      SIM.totalLaps = parseInt(lapsInput.value);
      SIM.safetyCar = false;
      totalLapsSpan.textContent = SIM.totalLaps;
      lapsSpan.textContent = SIM.totalLaps;
      
      SIM.cars.forEach(c => {
        c.pos = (c.id / SIM.cars.length) * 20;
        c.laps = 0;
        c.totalTime = 0;
        c.retired = false;
        c.finished = false;
        c.inPit = false;
        c.pitCount = 0;
        c.circ.setAttribute('opacity', 1);
        c.model.currentTire = ['soft', 'medium', 'hard'][Math.floor(Math.random() * 3)];
      });
      
      render();
    }

    // init
    initCars();
    resetRace();

    // initial render
    render();
  </script>
</body>
</html>